#![allow(unused_imports)]

use once_cell::sync::OnceCell;

use tracing::{debug, error, info, warn}; // Import tracing macros
use tracing_subscriber::layer::SubscriberExt as _;
use tracing_subscriber::util::SubscriberInitExt as _;
use tracing_subscriber::{fmt, EnvFilter};

// Declare modules
pub mod error;
pub mod addr;
pub mod network;
pub mod tx;
pub mod config;

// NAPI bindings module
#[cfg(feature = "napi")]
pub mod napi_bindings;

#[cfg(feature = "napi")]
pub mod test_napi;

// Re-export NAPI bindings for Node.js when the napi feature is enabled
#[cfg(feature = "napi")]
pub use napi_bindings::*;

// Import the functions needed by the UniFFI scaffolding
use crate::addr::validate_address;
use crate::network::Network;
use crate::error::ZecError;
use crate::tx::{UTXO, Output, Sighash, PartialTx, Sighashes, build_ptx, apply_signatures, compute_txid, get_ovk};
use crate::config::{Config, init_config, init_logger};


pub static CONFIG: OnceCell<Config> = OnceCell::new();

pub fn init_zec() -> Result<(), ZecError> {
    init_logger();
   
    let config_instance = init_config()?;
    match CONFIG.set(config_instance) { // Atomically sets the value once
        Ok(()) => info!("Global Rust zec configuration set."),
        Err(_) => warn!("Configuration already initialized."),
    }
    Ok(())
}

// Include the code generated by UniFFI based on interface.udl (only when uniffi feature is enabled)
#[cfg(feature = "uniffi")]
uniffi::include_scaffolding!("interface");

