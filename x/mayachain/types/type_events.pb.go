// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mayachain/v1/x/mayachain/types/type_events.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	common "gitlab.com/mayachain/mayanode/common"
	gitlab_com_mayachain_mayanode_common "gitlab.com/mayachain/mayanode/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PendingLiquidityType int32

const (
	PendingLiquidityType_add      PendingLiquidityType = 0
	PendingLiquidityType_withdraw PendingLiquidityType = 1
)

var PendingLiquidityType_name = map[int32]string{
	0: "add",
	1: "withdraw",
}

var PendingLiquidityType_value = map[string]int32{
	"add":      0,
	"withdraw": 1,
}

func (x PendingLiquidityType) String() string {
	return proto.EnumName(PendingLiquidityType_name, int32(x))
}

func (PendingLiquidityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{0}
}

type BondType int32

const (
	BondType_bond_paid        BondType = 0
	BondType_bond_returned    BondType = 1
	BondType_bond_reward      BondType = 2
	BondType_bond_cost        BondType = 3
	BondType_bond_reward_paid BondType = 4
)

var BondType_name = map[int32]string{
	0: "bond_paid",
	1: "bond_returned",
	2: "bond_reward",
	3: "bond_cost",
	4: "bond_reward_paid",
}

var BondType_value = map[string]int32{
	"bond_paid":        0,
	"bond_returned":    1,
	"bond_reward":      2,
	"bond_cost":        3,
	"bond_reward_paid": 4,
}

func (x BondType) String() string {
	return proto.EnumName(BondType_name, int32(x))
}

func (BondType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{1}
}

type PoolMod struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	CacaoAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=cacao_amt,json=cacaoAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amt"`
	CacaoAdd bool                                    `protobuf:"varint,3,opt,name=cacao_add,json=cacaoAdd,proto3" json:"cacao_add,omitempty"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	AssetAdd bool                                    `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (m *PoolMod) Reset()         { *m = PoolMod{} }
func (m *PoolMod) String() string { return proto.CompactTextString(m) }
func (*PoolMod) ProtoMessage()    {}
func (*PoolMod) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{0}
}
func (m *PoolMod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMod.Merge(m, src)
}
func (m *PoolMod) XXX_Size() int {
	return m.Size()
}
func (m *PoolMod) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMod.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMod proto.InternalMessageInfo

func (m *PoolMod) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolMod) GetCacaoAdd() bool {
	if m != nil {
		return m.CacaoAdd
	}
	return false
}

func (m *PoolMod) GetAssetAdd() bool {
	if m != nil {
		return m.AssetAdd
	}
	return false
}

type EventStreamingSwap struct {
	TxID              gitlab_com_mayachain_mayanode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	Interval          uint64                                    `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Quantity          uint64                                    `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Count             uint64                                    `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	LastHeight        int64                                     `protobuf:"varint,5,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
	TradeTarget       github_com_cosmos_cosmos_sdk_types.Uint   `protobuf:"bytes,6,opt,name=trade_target,json=tradeTarget,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"trade_target"`
	Deposit           common.Coin                               `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit"`
	In                common.Coin                               `protobuf:"bytes,8,opt,name=in,proto3" json:"in"`
	Out               common.Coin                               `protobuf:"bytes,9,opt,name=out,proto3" json:"out"`
	FailedSwaps       []uint64                                  `protobuf:"varint,10,rep,packed,name=failed_swaps,json=failedSwaps,proto3" json:"failed_swaps,omitempty"`
	FailedSwapReasons []string                                  `protobuf:"bytes,11,rep,name=failed_swap_reasons,json=failedSwapReasons,proto3" json:"failed_swap_reasons,omitempty"`
}

func (m *EventStreamingSwap) Reset()         { *m = EventStreamingSwap{} }
func (m *EventStreamingSwap) String() string { return proto.CompactTextString(m) }
func (*EventStreamingSwap) ProtoMessage()    {}
func (*EventStreamingSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{1}
}
func (m *EventStreamingSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamingSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamingSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamingSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamingSwap.Merge(m, src)
}
func (m *EventStreamingSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamingSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamingSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamingSwap proto.InternalMessageInfo

func (m *EventStreamingSwap) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventStreamingSwap) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *EventStreamingSwap) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *EventStreamingSwap) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *EventStreamingSwap) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *EventStreamingSwap) GetDeposit() common.Coin {
	if m != nil {
		return m.Deposit
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetIn() common.Coin {
	if m != nil {
		return m.In
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetOut() common.Coin {
	if m != nil {
		return m.Out
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetFailedSwaps() []uint64 {
	if m != nil {
		return m.FailedSwaps
	}
	return nil
}

func (m *EventStreamingSwap) GetFailedSwapReasons() []string {
	if m != nil {
		return m.FailedSwapReasons
	}
	return nil
}

type EventSwap struct {
	Pool                  common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SwapTarget            github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_target"`
	SwapSlip              github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_slip"`
	LiquidityFee          github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee"`
	LiquidityFeeInCacao   github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,5,opt,name=liquidity_fee_in_cacao,json=liquidityFeeInCacao,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee_in_cacao"`
	InTx                  common.Tx                               `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	OutTxs                common.Tx                               `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs"`
	EmitAsset             common.Coin                             `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset"`
	SynthUnits            github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
	StreamingSwapQuantity uint64                                  `protobuf:"varint,10,opt,name=streaming_swap_quantity,json=streamingSwapQuantity,proto3" json:"streaming_swap_quantity,omitempty"`
	StreamingSwapCount    uint64                                  `protobuf:"varint,11,opt,name=streaming_swap_count,json=streamingSwapCount,proto3" json:"streaming_swap_count,omitempty"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{2}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSwap) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventSwap) GetOutTxs() common.Tx {
	if m != nil {
		return m.OutTxs
	}
	return common.Tx{}
}

func (m *EventSwap) GetEmitAsset() common.Coin {
	if m != nil {
		return m.EmitAsset
	}
	return common.Coin{}
}

func (m *EventSwap) GetStreamingSwapQuantity() uint64 {
	if m != nil {
		return m.StreamingSwapQuantity
	}
	return 0
}

func (m *EventSwap) GetStreamingSwapCount() uint64 {
	if m != nil {
		return m.StreamingSwapCount
	}
	return 0
}

type EventAffiliateFee struct {
	TxID         gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	Memo         string                                       `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	Mayaname     string                                       `protobuf:"bytes,3,opt,name=mayaname,proto3" json:"mayaname,omitempty"`
	CacaoAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,4,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"cacao_address,omitempty"`
	Asset        common.Asset                                 `protobuf:"bytes,5,opt,name=asset,proto3" json:"asset"`
	GrossAmount  github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,6,opt,name=gross_amount,json=grossAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"gross_amount"`
	FeeBpsTick   uint64                                       `protobuf:"varint,7,opt,name=fee_bps_tick,json=feeBpsTick,proto3" json:"fee_bps_tick,omitempty"`
	FeeAmount    github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,8,opt,name=fee_amount,json=feeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"fee_amount"`
	Parent       string                                       `protobuf:"bytes,9,opt,name=parent,proto3" json:"parent,omitempty"`
	SubFeeBps    uint64                                       `protobuf:"varint,10,opt,name=sub_fee_bps,json=subFeeBps,proto3" json:"sub_fee_bps,omitempty"`
}

func (m *EventAffiliateFee) Reset()         { *m = EventAffiliateFee{} }
func (m *EventAffiliateFee) String() string { return proto.CompactTextString(m) }
func (*EventAffiliateFee) ProtoMessage()    {}
func (*EventAffiliateFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{3}
}
func (m *EventAffiliateFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAffiliateFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAffiliateFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAffiliateFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAffiliateFee.Merge(m, src)
}
func (m *EventAffiliateFee) XXX_Size() int {
	return m.Size()
}
func (m *EventAffiliateFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAffiliateFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventAffiliateFee proto.InternalMessageInfo

func (m *EventAffiliateFee) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventAffiliateFee) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *EventAffiliateFee) GetMayaname() string {
	if m != nil {
		return m.Mayaname
	}
	return ""
}

func (m *EventAffiliateFee) GetCacaoAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.CacaoAddress
	}
	return ""
}

func (m *EventAffiliateFee) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventAffiliateFee) GetFeeBpsTick() uint64 {
	if m != nil {
		return m.FeeBpsTick
	}
	return 0
}

func (m *EventAffiliateFee) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *EventAffiliateFee) GetSubFeeBps() uint64 {
	if m != nil {
		return m.SubFeeBps
	}
	return 0
}

type EventAddLiquidity struct {
	Pool          common.Asset                                 `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	CacaoAddress  gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,3,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"cacao_address,omitempty"`
	CacaoAmount   github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=cacao_amount,json=cacaoAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amount"`
	AssetAmount   github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amount"`
	RuneTxID      gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,6,opt,name=cacao_tx_id,json=cacaoTxId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"cacao_tx_id,omitempty"`
	AssetTxID     gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"asset_tx_id,omitempty"`
	AssetAddress  gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"asset_address,omitempty"`
}

func (m *EventAddLiquidity) Reset()         { *m = EventAddLiquidity{} }
func (m *EventAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventAddLiquidity) ProtoMessage()    {}
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{4}
}
func (m *EventAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAddLiquidity.Merge(m, src)
}
func (m *EventAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventAddLiquidity proto.InternalMessageInfo

func (m *EventAddLiquidity) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventAddLiquidity) GetCacaoAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.CacaoAddress
	}
	return ""
}

func (m *EventAddLiquidity) GetRuneTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	Pool              common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits     github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	BasisPoints       int64                                   `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry         github_com_cosmos_cosmos_sdk_types.Dec  `protobuf:"bytes,4,opt,name=asymmetry,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"asymmetry"`
	InTx              common.Tx                               `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	EmitAsset         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_asset"`
	EmitCacao         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,7,opt,name=emit_cacao,json=emitCacao,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_cacao"`
	ImpLossProtection github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,8,opt,name=imp_loss_protection,json=impLossProtection,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"imp_loss_protection"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{5}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventWithdraw) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPendingLiquidity struct {
	Pool         common.Asset                                 `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	PendingType  PendingLiquidityType                         `protobuf:"varint,2,opt,name=pending_type,json=pendingType,proto3,enum=types.PendingLiquidityType" json:"pending_type,omitempty"`
	CacaoAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,3,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"cacao_address,omitempty"`
	CacaoAmount  github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=cacao_amount,json=cacaoAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amount"`
	AssetAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,5,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"asset_address,omitempty"`
	AssetAmount  github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,6,opt,name=asset_amount,json=assetAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amount"`
	RuneTxID     gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,7,opt,name=cacao_tx_id,json=cacaoTxId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"cacao_tx_id,omitempty"`
	AssetTxID    gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,8,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"asset_tx_id,omitempty"`
}

func (m *EventPendingLiquidity) Reset()         { *m = EventPendingLiquidity{} }
func (m *EventPendingLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventPendingLiquidity) ProtoMessage()    {}
func (*EventPendingLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{6}
}
func (m *EventPendingLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPendingLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPendingLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPendingLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPendingLiquidity.Merge(m, src)
}
func (m *EventPendingLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventPendingLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPendingLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventPendingLiquidity proto.InternalMessageInfo

func (m *EventPendingLiquidity) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventPendingLiquidity) GetPendingType() PendingLiquidityType {
	if m != nil {
		return m.PendingType
	}
	return PendingLiquidityType_add
}

func (m *EventPendingLiquidity) GetCacaoAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.CacaoAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetRuneTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

type EventDonate struct {
	Pool common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	InTx common.Tx    `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventDonate) Reset()         { *m = EventDonate{} }
func (m *EventDonate) String() string { return proto.CompactTextString(m) }
func (*EventDonate) ProtoMessage()    {}
func (*EventDonate) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{7}
}
func (m *EventDonate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDonate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDonate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDonate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDonate.Merge(m, src)
}
func (m *EventDonate) XXX_Size() int {
	return m.Size()
}
func (m *EventDonate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDonate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDonate proto.InternalMessageInfo

func (m *EventDonate) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventDonate) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPool struct {
	Pool   common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	Status PoolStatus   `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (m *EventPool) Reset()         { *m = EventPool{} }
func (m *EventPool) String() string { return proto.CompactTextString(m) }
func (*EventPool) ProtoMessage()    {}
func (*EventPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{8}
}
func (m *EventPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPool.Merge(m, src)
}
func (m *EventPool) XXX_Size() int {
	return m.Size()
}
func (m *EventPool) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPool.DiscardUnknown(m)
}

var xxx_messageInfo_EventPool proto.InternalMessageInfo

func (m *EventPool) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	Asset  common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	Amount int64        `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *PoolAmt) Reset()         { *m = PoolAmt{} }
func (m *PoolAmt) String() string { return proto.CompactTextString(m) }
func (*PoolAmt) ProtoMessage()    {}
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{9}
}
func (m *PoolAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAmt.Merge(m, src)
}
func (m *PoolAmt) XXX_Size() int {
	return m.Size()
}
func (m *PoolAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAmt.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAmt proto.InternalMessageInfo

func (m *PoolAmt) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolAmt) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type EventRewardsV1 struct {
	BondReward  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"bond_reward"`
	PoolRewards []PoolAmt                               `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
}

func (m *EventRewardsV1) Reset()         { *m = EventRewardsV1{} }
func (m *EventRewardsV1) String() string { return proto.CompactTextString(m) }
func (*EventRewardsV1) ProtoMessage()    {}
func (*EventRewardsV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{10}
}
func (m *EventRewardsV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewardsV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewardsV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewardsV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewardsV1.Merge(m, src)
}
func (m *EventRewardsV1) XXX_Size() int {
	return m.Size()
}
func (m *EventRewardsV1) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewardsV1.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewardsV1 proto.InternalMessageInfo

func (m *EventRewardsV1) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRewards struct {
	BondReward      github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"bond_reward"`
	PoolRewards     []PoolAmt                               `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
	CacaoPoolReward github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=cacao_pool_reward,json=cacaoPoolReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_pool_reward"`
	MayaFundReward  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=maya_fund_reward,json=mayaFundReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"maya_fund_reward"`
}

func (m *EventRewards) Reset()         { *m = EventRewards{} }
func (m *EventRewards) String() string { return proto.CompactTextString(m) }
func (*EventRewards) ProtoMessage()    {}
func (*EventRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{11}
}
func (m *EventRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewards.Merge(m, src)
}
func (m *EventRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewards proto.InternalMessageInfo

func (m *EventRewards) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRefund struct {
	Code   uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	Fee    common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
}

func (m *EventRefund) Reset()         { *m = EventRefund{} }
func (m *EventRefund) String() string { return proto.CompactTextString(m) }
func (*EventRefund) ProtoMessage()    {}
func (*EventRefund) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{12}
}
func (m *EventRefund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRefund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRefund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRefund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRefund.Merge(m, src)
}
func (m *EventRefund) XXX_Size() int {
	return m.Size()
}
func (m *EventRefund) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRefund.DiscardUnknown(m)
}

var xxx_messageInfo_EventRefund proto.InternalMessageInfo

func (m *EventRefund) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventRefund) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventRefund) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventRefund) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventBond struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	BondType BondType                                `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn     common.Tx                               `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
}

func (m *EventBond) Reset()         { *m = EventBond{} }
func (m *EventBond) String() string { return proto.CompactTextString(m) }
func (*EventBond) ProtoMessage()    {}
func (*EventBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{13}
}
func (m *EventBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBond.Merge(m, src)
}
func (m *EventBond) XXX_Size() int {
	return m.Size()
}
func (m *EventBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventBond proto.InternalMessageInfo

func (m *EventBond) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

type EventBondV105 struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	BondType BondType                                `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn     common.Tx                               `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
	Asset    common.Asset                            `protobuf:"bytes,4,opt,name=asset,proto3" json:"asset"`
}

func (m *EventBondV105) Reset()         { *m = EventBondV105{} }
func (m *EventBondV105) String() string { return proto.CompactTextString(m) }
func (*EventBondV105) ProtoMessage()    {}
func (*EventBondV105) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{14}
}
func (m *EventBondV105) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBondV105) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBondV105.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBondV105) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBondV105.Merge(m, src)
}
func (m *EventBondV105) XXX_Size() int {
	return m.Size()
}
func (m *EventBondV105) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBondV105.DiscardUnknown(m)
}

var xxx_messageInfo_EventBondV105 proto.InternalMessageInfo

func (m *EventBondV105) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBondV105) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

func (m *EventBondV105) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

type GasPool struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	CacaoAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=cacao_amt,json=cacaoAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amt"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	Count    int64                                   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GasPool) Reset()         { *m = GasPool{} }
func (m *GasPool) String() string { return proto.CompactTextString(m) }
func (*GasPool) ProtoMessage()    {}
func (*GasPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{15}
}
func (m *GasPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPool.Merge(m, src)
}
func (m *GasPool) XXX_Size() int {
	return m.Size()
}
func (m *GasPool) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPool.DiscardUnknown(m)
}

var xxx_messageInfo_GasPool proto.InternalMessageInfo

func (m *GasPool) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *GasPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EventGas struct {
	Pools []GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
}

func (m *EventGas) Reset()         { *m = EventGas{} }
func (m *EventGas) String() string { return proto.CompactTextString(m) }
func (*EventGas) ProtoMessage()    {}
func (*EventGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{16}
}
func (m *EventGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGas.Merge(m, src)
}
func (m *EventGas) XXX_Size() int {
	return m.Size()
}
func (m *EventGas) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGas.DiscardUnknown(m)
}

var xxx_messageInfo_EventGas proto.InternalMessageInfo

func (m *EventGas) GetPools() []GasPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventReserve struct {
	ReserveContributor ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor"`
	InTx               common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventReserve) Reset()         { *m = EventReserve{} }
func (m *EventReserve) String() string { return proto.CompactTextString(m) }
func (*EventReserve) ProtoMessage()    {}
func (*EventReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{17}
}
func (m *EventReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReserve.Merge(m, src)
}
func (m *EventReserve) XXX_Size() int {
	return m.Size()
}
func (m *EventReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReserve.DiscardUnknown(m)
}

var xxx_messageInfo_EventReserve proto.InternalMessageInfo

func (m *EventReserve) GetReserveContributor() ReserveContributor {
	if m != nil {
		return m.ReserveContributor
	}
	return ReserveContributor{}
}

func (m *EventReserve) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventScheduledOutbound struct {
	OutTx TxOutItem `protobuf:"bytes,1,opt,name=out_tx,json=outTx,proto3" json:"out_tx"`
}

func (m *EventScheduledOutbound) Reset()         { *m = EventScheduledOutbound{} }
func (m *EventScheduledOutbound) String() string { return proto.CompactTextString(m) }
func (*EventScheduledOutbound) ProtoMessage()    {}
func (*EventScheduledOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{18}
}
func (m *EventScheduledOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventScheduledOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventScheduledOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventScheduledOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventScheduledOutbound.Merge(m, src)
}
func (m *EventScheduledOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventScheduledOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventScheduledOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventScheduledOutbound proto.InternalMessageInfo

func (m *EventScheduledOutbound) GetOutTx() TxOutItem {
	if m != nil {
		return m.OutTx
	}
	return TxOutItem{}
}

type EventSecurity struct {
	Msg string    `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Tx  common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventSecurity) Reset()         { *m = EventSecurity{} }
func (m *EventSecurity) String() string { return proto.CompactTextString(m) }
func (*EventSecurity) ProtoMessage()    {}
func (*EventSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{19}
}
func (m *EventSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecurity.Merge(m, src)
}
func (m *EventSecurity) XXX_Size() int {
	return m.Size()
}
func (m *EventSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecurity proto.InternalMessageInfo

func (m *EventSecurity) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EventSecurity) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventSlash struct {
	Pool        common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SlashAmount []PoolAmt    `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{20}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSlash) GetSlashAmount() []PoolAmt {
	if m != nil {
		return m.SlashAmount
	}
	return nil
}

type EventSlashLiquidity struct {
	NodeBondAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_bond_address,json=nodeBondAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_bond_address,omitempty"`
	Asset           common.Asset                                  `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	Address         gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,3,opt,name=address,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"address,omitempty"`
	LpUnits         github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=lp_units,json=lpUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"lp_units"`
}

func (m *EventSlashLiquidity) Reset()         { *m = EventSlashLiquidity{} }
func (m *EventSlashLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventSlashLiquidity) ProtoMessage()    {}
func (*EventSlashLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{21}
}
func (m *EventSlashLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashLiquidity.Merge(m, src)
}
func (m *EventSlashLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashLiquidity proto.InternalMessageInfo

func (m *EventSlashLiquidity) GetNodeBondAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeBondAddress
	}
	return nil
}

func (m *EventSlashLiquidity) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSlashLiquidity) GetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventErrata struct {
	TxID  gitlab_com_mayachain_mayanode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	Pools PoolMods                                  `protobuf:"bytes,2,rep,name=pools,proto3,castrepeated=PoolMods" json:"pools"`
}

func (m *EventErrata) Reset()         { *m = EventErrata{} }
func (m *EventErrata) String() string { return proto.CompactTextString(m) }
func (*EventErrata) ProtoMessage()    {}
func (*EventErrata) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{22}
}
func (m *EventErrata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventErrata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventErrata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventErrata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventErrata.Merge(m, src)
}
func (m *EventErrata) XXX_Size() int {
	return m.Size()
}
func (m *EventErrata) XXX_DiscardUnknown() {
	xxx_messageInfo_EventErrata.DiscardUnknown(m)
}

var xxx_messageInfo_EventErrata proto.InternalMessageInfo

func (m *EventErrata) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventErrata) GetPools() PoolMods {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventFee struct {
	TxID       gitlab_com_mayachain_mayanode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	Fee        common.Fee                                `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
	SynthUnits github_com_cosmos_cosmos_sdk_types.Uint   `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
}

func (m *EventFee) Reset()         { *m = EventFee{} }
func (m *EventFee) String() string { return proto.CompactTextString(m) }
func (*EventFee) ProtoMessage()    {}
func (*EventFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{23}
}
func (m *EventFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFee.Merge(m, src)
}
func (m *EventFee) XXX_Size() int {
	return m.Size()
}
func (m *EventFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventFee proto.InternalMessageInfo

func (m *EventFee) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventFee) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventOutbound struct {
	InTxID gitlab_com_mayachain_mayanode_common.TxID `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"in_tx_id,omitempty"`
	Tx     common.Tx                                 `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventOutbound) Reset()         { *m = EventOutbound{} }
func (m *EventOutbound) String() string { return proto.CompactTextString(m) }
func (*EventOutbound) ProtoMessage()    {}
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{24}
}
func (m *EventOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutbound.Merge(m, src)
}
func (m *EventOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutbound proto.InternalMessageInfo

func (m *EventOutbound) GetInTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.InTxID
	}
	return ""
}

func (m *EventOutbound) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventTssKeygenSuccess struct {
	PubKey  gitlab_com_mayachain_mayanode_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/mayachain/mayanode/common.PubKey" json:"pub_key,omitempty"`
	Members []string                                    `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Height  int64                                       `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenSuccess) Reset()         { *m = EventTssKeygenSuccess{} }
func (m *EventTssKeygenSuccess) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenSuccess) ProtoMessage()    {}
func (*EventTssKeygenSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{25}
}
func (m *EventTssKeygenSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenSuccess.Merge(m, src)
}
func (m *EventTssKeygenSuccess) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenSuccess proto.InternalMessageInfo

func (m *EventTssKeygenSuccess) GetPubKey() gitlab_com_mayachain_mayanode_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenSuccess) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *EventTssKeygenSuccess) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenFailure struct {
	FailReason string   `protobuf:"bytes,1,opt,name=fail_reason,json=failReason,proto3" json:"fail_reason,omitempty"`
	IsUnicast  bool     `protobuf:"varint,2,opt,name=is_unicast,json=isUnicast,proto3" json:"is_unicast,omitempty"`
	BlameNodes []string `protobuf:"bytes,3,rep,name=blame_nodes,json=blameNodes,proto3" json:"blame_nodes,omitempty"`
	Round      string   `protobuf:"bytes,4,opt,name=round,proto3" json:"round,omitempty"`
	Height     int64    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenFailure) Reset()         { *m = EventTssKeygenFailure{} }
func (m *EventTssKeygenFailure) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenFailure) ProtoMessage()    {}
func (*EventTssKeygenFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{26}
}
func (m *EventTssKeygenFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenFailure.Merge(m, src)
}
func (m *EventTssKeygenFailure) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenFailure.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenFailure proto.InternalMessageInfo

func (m *EventTssKeygenFailure) GetFailReason() string {
	if m != nil {
		return m.FailReason
	}
	return ""
}

func (m *EventTssKeygenFailure) GetIsUnicast() bool {
	if m != nil {
		return m.IsUnicast
	}
	return false
}

func (m *EventTssKeygenFailure) GetBlameNodes() []string {
	if m != nil {
		return m.BlameNodes
	}
	return nil
}

func (m *EventTssKeygenFailure) GetRound() string {
	if m != nil {
		return m.Round
	}
	return ""
}

func (m *EventTssKeygenFailure) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenMetric struct {
	PubKey           gitlab_com_mayachain_mayanode_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/mayachain/mayanode/common.PubKey" json:"pub_key,omitempty"`
	MedianDurationMs int64                                       `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeygenMetric) Reset()         { *m = EventTssKeygenMetric{} }
func (m *EventTssKeygenMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenMetric) ProtoMessage()    {}
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{27}
}
func (m *EventTssKeygenMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenMetric.Merge(m, src)
}
func (m *EventTssKeygenMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenMetric proto.InternalMessageInfo

func (m *EventTssKeygenMetric) GetPubKey() gitlab_com_mayachain_mayanode_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	TxID             gitlab_com_mayachain_mayanode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	MedianDurationMs int64                                     `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeysignMetric) Reset()         { *m = EventTssKeysignMetric{} }
func (m *EventTssKeysignMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeysignMetric) ProtoMessage()    {}
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{28}
}
func (m *EventTssKeysignMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeysignMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeysignMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeysignMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeysignMetric.Merge(m, src)
}
func (m *EventTssKeysignMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeysignMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeysignMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeysignMetric proto.InternalMessageInfo

func (m *EventTssKeysignMetric) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	SlashPoints int64                                         `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string                                        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSlashPoint) Reset()         { *m = EventSlashPoint{} }
func (m *EventSlashPoint) String() string { return proto.CompactTextString(m) }
func (*EventSlashPoint) ProtoMessage()    {}
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{29}
}
func (m *EventSlashPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashPoint.Merge(m, src)
}
func (m *EventSlashPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashPoint proto.InternalMessageInfo

func (m *EventSlashPoint) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventSlashPoint) GetSlashPoints() int64 {
	if m != nil {
		return m.SlashPoints
	}
	return 0
}

func (m *EventSlashPoint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	PoolChange PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change"`
	Reason     string  `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventPoolBalanceChanged) Reset()         { *m = EventPoolBalanceChanged{} }
func (m *EventPoolBalanceChanged) String() string { return proto.CompactTextString(m) }
func (*EventPoolBalanceChanged) ProtoMessage()    {}
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{30}
}
func (m *EventPoolBalanceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolBalanceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolBalanceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolBalanceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolBalanceChanged.Merge(m, src)
}
func (m *EventPoolBalanceChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolBalanceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolBalanceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolBalanceChanged proto.InternalMessageInfo

func (m *EventPoolBalanceChanged) GetPoolChange() PoolMod {
	if m != nil {
		return m.PoolChange
	}
	return PoolMod{}
}

func (m *EventPoolBalanceChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventSwitch struct {
	ToAddress   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"to_address,omitempty"`
	FromAddress gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"from_address,omitempty"`
	Burn        common.Coin                                   `protobuf:"bytes,3,opt,name=burn,proto3" json:"burn"`
	TxID        gitlab_com_mayachain_mayanode_common.TxID     `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSwitch) Reset()         { *m = EventSwitch{} }
func (m *EventSwitch) String() string { return proto.CompactTextString(m) }
func (*EventSwitch) ProtoMessage()    {}
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{31}
}
func (m *EventSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitch.Merge(m, src)
}
func (m *EventSwitch) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitch proto.InternalMessageInfo

func (m *EventSwitch) GetToAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ToAddress
	}
	return nil
}

func (m *EventSwitch) GetFromAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *EventSwitch) GetBurn() common.Coin {
	if m != nil {
		return m.Burn
	}
	return common.Coin{}
}

func (m *EventSwitch) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSwitchV87 struct {
	ToAddress   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"to_address,omitempty"`
	FromAddress gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"from_address,omitempty"`
	Burn        common.Coin                                   `protobuf:"bytes,3,opt,name=burn,proto3" json:"burn"`
	TxID        gitlab_com_mayachain_mayanode_common.TxID     `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	Mint        github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,5,opt,name=mint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"mint"`
}

func (m *EventSwitchV87) Reset()         { *m = EventSwitchV87{} }
func (m *EventSwitchV87) String() string { return proto.CompactTextString(m) }
func (*EventSwitchV87) ProtoMessage()    {}
func (*EventSwitchV87) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{32}
}
func (m *EventSwitchV87) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitchV87) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitchV87.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitchV87) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitchV87.Merge(m, src)
}
func (m *EventSwitchV87) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitchV87) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitchV87.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitchV87 proto.InternalMessageInfo

func (m *EventSwitchV87) GetToAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ToAddress
	}
	return nil
}

func (m *EventSwitchV87) GetFromAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *EventSwitchV87) GetBurn() common.Coin {
	if m != nil {
		return m.Burn
	}
	return common.Coin{}
}

func (m *EventSwitchV87) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventMAYANameV111 struct {
	Name            string                                        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain           gitlab_com_mayachain_mayanode_common.Chain    `protobuf:"bytes,2,opt,name=chain,proto3,casttype=gitlab.com/mayachain/mayanode/common.Chain" json:"chain,omitempty"`
	Address         gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,3,opt,name=address,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"address,omitempty"`
	RegistrationFee github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"registration_fee"`
	FundAmt         github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"fund_amt"`
	Expire          int64                                         `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner           github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
}

func (m *EventMAYANameV111) Reset()         { *m = EventMAYANameV111{} }
func (m *EventMAYANameV111) String() string { return proto.CompactTextString(m) }
func (*EventMAYANameV111) ProtoMessage()    {}
func (*EventMAYANameV111) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{33}
}
func (m *EventMAYANameV111) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMAYANameV111) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMAYANameV111.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMAYANameV111) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMAYANameV111.Merge(m, src)
}
func (m *EventMAYANameV111) XXX_Size() int {
	return m.Size()
}
func (m *EventMAYANameV111) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMAYANameV111.DiscardUnknown(m)
}

var xxx_messageInfo_EventMAYANameV111 proto.InternalMessageInfo

func (m *EventMAYANameV111) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventMAYANameV111) GetChain() gitlab_com_mayachain_mayanode_common.Chain {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *EventMAYANameV111) GetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventMAYANameV111) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *EventMAYANameV111) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

type EventMAYAName struct {
	Name             string                                        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain            gitlab_com_mayachain_mayanode_common.Chain    `protobuf:"bytes,2,opt,name=chain,proto3,casttype=gitlab.com/mayachain/mayanode/common.Chain" json:"chain,omitempty"`
	Address          gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,3,opt,name=address,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"address,omitempty"`
	RegistrationFee  github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"registration_fee"`
	FundAmt          github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"fund_amt"`
	Expire           int64                                         `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner            github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	AffiliateBps     int64                                         `protobuf:"varint,8,opt,name=affiliate_bps,json=affiliateBps,proto3" json:"affiliate_bps,omitempty"`
	SubaffiliateName []string                                      `protobuf:"bytes,9,rep,name=subaffiliate_name,json=subaffiliateName,proto3" json:"subaffiliate_name,omitempty"`
	SubaffiliateBps  []github_com_cosmos_cosmos_sdk_types.Uint     `protobuf:"bytes,10,rep,name=subaffiliate_bps,json=subaffiliateBps,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"subaffiliate_bps"`
}

func (m *EventMAYAName) Reset()         { *m = EventMAYAName{} }
func (m *EventMAYAName) String() string { return proto.CompactTextString(m) }
func (*EventMAYAName) ProtoMessage()    {}
func (*EventMAYAName) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{34}
}
func (m *EventMAYAName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMAYAName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMAYAName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMAYAName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMAYAName.Merge(m, src)
}
func (m *EventMAYAName) XXX_Size() int {
	return m.Size()
}
func (m *EventMAYAName) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMAYAName.DiscardUnknown(m)
}

var xxx_messageInfo_EventMAYAName proto.InternalMessageInfo

func (m *EventMAYAName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventMAYAName) GetChain() gitlab_com_mayachain_mayanode_common.Chain {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *EventMAYAName) GetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventMAYAName) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *EventMAYAName) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *EventMAYAName) GetAffiliateBps() int64 {
	if m != nil {
		return m.AffiliateBps
	}
	return 0
}

func (m *EventMAYAName) GetSubaffiliateName() []string {
	if m != nil {
		return m.SubaffiliateName
	}
	return nil
}

type EventSetMimir struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EventSetMimir) Reset()         { *m = EventSetMimir{} }
func (m *EventSetMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetMimir) ProtoMessage()    {}
func (*EventSetMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{35}
}
func (m *EventSetMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetMimir.Merge(m, src)
}
func (m *EventSetMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetMimir proto.InternalMessageInfo

func (m *EventSetMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type EventSetNodeMimir struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EventSetNodeMimir) Reset()         { *m = EventSetNodeMimir{} }
func (m *EventSetNodeMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetNodeMimir) ProtoMessage()    {}
func (*EventSetNodeMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{36}
}
func (m *EventSetNodeMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetNodeMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetNodeMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetNodeMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetNodeMimir.Merge(m, src)
}
func (m *EventSetNodeMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetNodeMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetNodeMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetNodeMimir proto.InternalMessageInfo

func (m *EventSetNodeMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetNodeMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *EventSetNodeMimir) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventCACAOPoolDeposit struct {
	CacaoAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"cacao_address,omitempty"`
	CacaoAmount  github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,2,opt,name=cacao_amount,json=cacaoAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amount"`
	Units        github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,3,opt,name=units,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"units"`
	TxId         gitlab_com_mayachain_mayanode_common.TxID     `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventCACAOPoolDeposit) Reset()         { *m = EventCACAOPoolDeposit{} }
func (m *EventCACAOPoolDeposit) String() string { return proto.CompactTextString(m) }
func (*EventCACAOPoolDeposit) ProtoMessage()    {}
func (*EventCACAOPoolDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{37}
}
func (m *EventCACAOPoolDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCACAOPoolDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCACAOPoolDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCACAOPoolDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCACAOPoolDeposit.Merge(m, src)
}
func (m *EventCACAOPoolDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventCACAOPoolDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCACAOPoolDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventCACAOPoolDeposit proto.InternalMessageInfo

func (m *EventCACAOPoolDeposit) GetCacaoAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.CacaoAddress
	}
	return nil
}

func (m *EventCACAOPoolDeposit) GetTxId() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

type EventCACAOPoolWithdrawV118 struct {
	CacaoAddress      github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"cacao_address,omitempty"`
	BasisPoints       int64                                         `protobuf:"varint,2,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	CacaoAmount       github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,3,opt,name=cacao_amount,json=cacaoAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amount"`
	Units             github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=units,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"units"`
	TxId              gitlab_com_mayachain_mayanode_common.TxID     `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	AffiliateBasisPts int64                                         `protobuf:"varint,6,opt,name=affiliate_basis_pts,json=affiliateBasisPts,proto3" json:"affiliate_basis_pts,omitempty"`
	AffiliateAmount   github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,7,opt,name=affiliate_amount,json=affiliateAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"affiliate_amount"`
	AffiliateAddress  gitlab_com_mayachain_mayanode_common.Address  `protobuf:"bytes,8,opt,name=affiliate_address,json=affiliateAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"affiliate_address,omitempty"`
}

func (m *EventCACAOPoolWithdrawV118) Reset()         { *m = EventCACAOPoolWithdrawV118{} }
func (m *EventCACAOPoolWithdrawV118) String() string { return proto.CompactTextString(m) }
func (*EventCACAOPoolWithdrawV118) ProtoMessage()    {}
func (*EventCACAOPoolWithdrawV118) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{38}
}
func (m *EventCACAOPoolWithdrawV118) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCACAOPoolWithdrawV118) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCACAOPoolWithdrawV118.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCACAOPoolWithdrawV118) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCACAOPoolWithdrawV118.Merge(m, src)
}
func (m *EventCACAOPoolWithdrawV118) XXX_Size() int {
	return m.Size()
}
func (m *EventCACAOPoolWithdrawV118) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCACAOPoolWithdrawV118.DiscardUnknown(m)
}

var xxx_messageInfo_EventCACAOPoolWithdrawV118 proto.InternalMessageInfo

func (m *EventCACAOPoolWithdrawV118) GetCacaoAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.CacaoAddress
	}
	return nil
}

func (m *EventCACAOPoolWithdrawV118) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventCACAOPoolWithdrawV118) GetTxId() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *EventCACAOPoolWithdrawV118) GetAffiliateBasisPts() int64 {
	if m != nil {
		return m.AffiliateBasisPts
	}
	return 0
}

func (m *EventCACAOPoolWithdrawV118) GetAffiliateAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.AffiliateAddress
	}
	return ""
}

type EventCACAOPoolWithdraw struct {
	CacaoAddress      github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"cacao_address,omitempty"`
	BasisPoints       int64                                         `protobuf:"varint,2,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	CacaoAmount       github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,3,opt,name=cacao_amount,json=cacaoAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"cacao_amount"`
	Units             github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=units,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"units"`
	TxId              gitlab_com_mayachain_mayanode_common.TxID     `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
	AffiliateBasisPts int64                                         `protobuf:"varint,6,opt,name=affiliate_basis_pts,json=affiliateBasisPts,proto3" json:"affiliate_basis_pts,omitempty"`
	AffiliateAmount   github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,7,opt,name=affiliate_amount,json=affiliateAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"affiliate_amount"`
}

func (m *EventCACAOPoolWithdraw) Reset()         { *m = EventCACAOPoolWithdraw{} }
func (m *EventCACAOPoolWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventCACAOPoolWithdraw) ProtoMessage()    {}
func (*EventCACAOPoolWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{39}
}
func (m *EventCACAOPoolWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCACAOPoolWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCACAOPoolWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCACAOPoolWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCACAOPoolWithdraw.Merge(m, src)
}
func (m *EventCACAOPoolWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventCACAOPoolWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCACAOPoolWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventCACAOPoolWithdraw proto.InternalMessageInfo

func (m *EventCACAOPoolWithdraw) GetCacaoAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.CacaoAddress
	}
	return nil
}

func (m *EventCACAOPoolWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventCACAOPoolWithdraw) GetTxId() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *EventCACAOPoolWithdraw) GetAffiliateBasisPts() int64 {
	if m != nil {
		return m.AffiliateBasisPts
	}
	return 0
}

type EventTradeAccountDeposit struct {
	Amount       github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	Asset        common.Asset                                 `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"asset_address,omitempty"`
	CacaoAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,4,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"cacao_address,omitempty"`
	TxID         gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountDeposit) Reset()         { *m = EventTradeAccountDeposit{} }
func (m *EventTradeAccountDeposit) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountDeposit) ProtoMessage()    {}
func (*EventTradeAccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{40}
}
func (m *EventTradeAccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountDeposit.Merge(m, src)
}
func (m *EventTradeAccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountDeposit proto.InternalMessageInfo

func (m *EventTradeAccountDeposit) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventTradeAccountDeposit) GetAssetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetCacaoAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.CacaoAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTradeAccountWithdraw struct {
	Amount       github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	Asset        common.Asset                                 `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"asset_address,omitempty"`
	CacaoAddress gitlab_com_mayachain_mayanode_common.Address `protobuf:"bytes,4,opt,name=cacao_address,json=cacaoAddress,proto3,casttype=gitlab.com/mayachain/mayanode/common.Address" json:"cacao_address,omitempty"`
	TxID         gitlab_com_mayachain_mayanode_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/mayachain/mayanode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountWithdraw) Reset()         { *m = EventTradeAccountWithdraw{} }
func (m *EventTradeAccountWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountWithdraw) ProtoMessage()    {}
func (*EventTradeAccountWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd2486ffd24912c2, []int{41}
}
func (m *EventTradeAccountWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountWithdraw.Merge(m, src)
}
func (m *EventTradeAccountWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountWithdraw proto.InternalMessageInfo

func (m *EventTradeAccountWithdraw) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventTradeAccountWithdraw) GetAssetAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetCacaoAddress() gitlab_com_mayachain_mayanode_common.Address {
	if m != nil {
		return m.CacaoAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetTxID() gitlab_com_mayachain_mayanode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.PendingLiquidityType", PendingLiquidityType_name, PendingLiquidityType_value)
	proto.RegisterEnum("types.BondType", BondType_name, BondType_value)
	proto.RegisterType((*PoolMod)(nil), "types.PoolMod")
	proto.RegisterType((*EventStreamingSwap)(nil), "types.EventStreamingSwap")
	proto.RegisterType((*EventSwap)(nil), "types.EventSwap")
	proto.RegisterType((*EventAffiliateFee)(nil), "types.EventAffiliateFee")
	proto.RegisterType((*EventAddLiquidity)(nil), "types.EventAddLiquidity")
	proto.RegisterType((*EventWithdraw)(nil), "types.EventWithdraw")
	proto.RegisterType((*EventPendingLiquidity)(nil), "types.EventPendingLiquidity")
	proto.RegisterType((*EventDonate)(nil), "types.EventDonate")
	proto.RegisterType((*EventPool)(nil), "types.EventPool")
	proto.RegisterType((*PoolAmt)(nil), "types.PoolAmt")
	proto.RegisterType((*EventRewardsV1)(nil), "types.EventRewardsV1")
	proto.RegisterType((*EventRewards)(nil), "types.EventRewards")
	proto.RegisterType((*EventRefund)(nil), "types.EventRefund")
	proto.RegisterType((*EventBond)(nil), "types.EventBond")
	proto.RegisterType((*EventBondV105)(nil), "types.EventBondV105")
	proto.RegisterType((*GasPool)(nil), "types.GasPool")
	proto.RegisterType((*EventGas)(nil), "types.EventGas")
	proto.RegisterType((*EventReserve)(nil), "types.EventReserve")
	proto.RegisterType((*EventScheduledOutbound)(nil), "types.EventScheduledOutbound")
	proto.RegisterType((*EventSecurity)(nil), "types.EventSecurity")
	proto.RegisterType((*EventSlash)(nil), "types.EventSlash")
	proto.RegisterType((*EventSlashLiquidity)(nil), "types.EventSlashLiquidity")
	proto.RegisterType((*EventErrata)(nil), "types.EventErrata")
	proto.RegisterType((*EventFee)(nil), "types.EventFee")
	proto.RegisterType((*EventOutbound)(nil), "types.EventOutbound")
	proto.RegisterType((*EventTssKeygenSuccess)(nil), "types.EventTssKeygenSuccess")
	proto.RegisterType((*EventTssKeygenFailure)(nil), "types.EventTssKeygenFailure")
	proto.RegisterType((*EventTssKeygenMetric)(nil), "types.EventTssKeygenMetric")
	proto.RegisterType((*EventTssKeysignMetric)(nil), "types.EventTssKeysignMetric")
	proto.RegisterType((*EventSlashPoint)(nil), "types.EventSlashPoint")
	proto.RegisterType((*EventPoolBalanceChanged)(nil), "types.EventPoolBalanceChanged")
	proto.RegisterType((*EventSwitch)(nil), "types.EventSwitch")
	proto.RegisterType((*EventSwitchV87)(nil), "types.EventSwitchV87")
	proto.RegisterType((*EventMAYANameV111)(nil), "types.EventMAYANameV111")
	proto.RegisterType((*EventMAYAName)(nil), "types.EventMAYAName")
	proto.RegisterType((*EventSetMimir)(nil), "types.EventSetMimir")
	proto.RegisterType((*EventSetNodeMimir)(nil), "types.EventSetNodeMimir")
	proto.RegisterType((*EventCACAOPoolDeposit)(nil), "types.EventCACAOPoolDeposit")
	proto.RegisterType((*EventCACAOPoolWithdrawV118)(nil), "types.EventCACAOPoolWithdrawV118")
	proto.RegisterType((*EventCACAOPoolWithdraw)(nil), "types.EventCACAOPoolWithdraw")
	proto.RegisterType((*EventTradeAccountDeposit)(nil), "types.EventTradeAccountDeposit")
	proto.RegisterType((*EventTradeAccountWithdraw)(nil), "types.EventTradeAccountWithdraw")
}

func init() {
	proto.RegisterFile("mayachain/v1/x/mayachain/types/type_events.proto", fileDescriptor_dd2486ffd24912c2)
}

var fileDescriptor_dd2486ffd24912c2 = []byte{
	// 2714 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0x37, 0xb9, 0x7c, 0x7e, 0xa4, 0x2c, 0x6a, 0xec, 0x38, 0x8c, 0x83, 0x8a, 0xca, 0xa6, 0x4d,
	0x64, 0xc7, 0x96, 0x2c, 0x17, 0x89, 0xd3, 0x02, 0x2d, 0x40, 0x4a, 0xb1, 0x23, 0xc7, 0x72, 0x94,
	0x95, 0xac, 0x22, 0x2e, 0x82, 0xc5, 0x72, 0x77, 0x44, 0x0d, 0xcc, 0x7d, 0x64, 0x67, 0x56, 0xa2,
	0xee, 0x2d, 0xfa, 0x00, 0xfa, 0x42, 0x8f, 0x3d, 0xb5, 0x87, 0xa2, 0xe9, 0x3f, 0xd0, 0x7b, 0x4f,
	0xb9, 0xb4, 0x48, 0x6e, 0x41, 0x0f, 0x6a, 0xab, 0x00, 0x3d, 0x15, 0x45, 0xcf, 0x3e, 0x14, 0xc5,
	0x3c, 0x76, 0x49, 0x8a, 0x91, 0x42, 0xad, 0x98, 0x26, 0x41, 0x7d, 0x91, 0x76, 0x5e, 0xbf, 0xf9,
	0xe6, 0x7b, 0xcf, 0x37, 0x84, 0x1b, 0xae, 0xb5, 0x6f, 0xd9, 0x3b, 0x16, 0xf1, 0x16, 0x77, 0x97,
	0x16, 0x7b, 0x8b, 0xfd, 0x26, 0xdb, 0x0f, 0x30, 0x15, 0x7f, 0x4d, 0xbc, 0x8b, 0x3d, 0x46, 0x17,
	0x82, 0xd0, 0x67, 0x3e, 0xca, 0x8b, 0x81, 0xcb, 0x73, 0x43, 0x0b, 0x6d, 0xdf, 0x75, 0x7d, 0x4f,
	0xfd, 0x93, 0x13, 0x2f, 0x2f, 0x8c, 0x03, 0x1d, 0xf8, 0x7e, 0x57, 0xcd, 0xff, 0xd6, 0x38, 0xf3,
	0x43, 0x4c, 0x71, 0xb8, 0x8b, 0x4d, 0xdb, 0xf7, 0x58, 0x48, 0xda, 0x11, 0xf3, 0x43, 0xb5, 0x7c,
	0xac, 0x93, 0xb0, 0x9e, 0xe9, 0x47, 0x4c, 0xad, 0xb8, 0xd8, 0xf1, 0x3b, 0xbe, 0xf8, 0x5c, 0xe4,
	0x5f, 0xb2, 0x57, 0xff, 0x71, 0x16, 0x8a, 0xeb, 0xbe, 0xdf, 0x5d, 0xf3, 0x1d, 0x74, 0x05, 0xf2,
	0x16, 0xa5, 0x98, 0xd5, 0x33, 0x73, 0x99, 0xf9, 0xca, 0xcd, 0xa9, 0x05, 0x75, 0xc0, 0x26, 0xef,
	0x6c, 0xe5, 0xde, 0x3f, 0x68, 0x9c, 0x33, 0xe4, 0x0c, 0x74, 0x0f, 0xca, 0xb6, 0x65, 0x5b, 0xbe,
	0x69, 0xb9, 0xac, 0x9e, 0x9d, 0xcb, 0xcc, 0x97, 0x5b, 0x8b, 0x7c, 0xfc, 0x2f, 0x07, 0x8d, 0x17,
	0x3b, 0x84, 0xed, 0x44, 0x6d, 0xbe, 0x78, 0xd1, 0xf6, 0xa9, 0xeb, 0x53, 0xf5, 0xef, 0x3a, 0x75,
	0x1e, 0x49, 0xea, 0x16, 0x1e, 0x10, 0x8f, 0x19, 0x25, 0x81, 0xd0, 0x74, 0x19, 0x7a, 0x36, 0x41,
	0x73, 0x9c, 0xba, 0x36, 0x97, 0x99, 0x2f, 0xc5, 0x83, 0x8e, 0xc3, 0xb7, 0x12, 0x7b, 0x8a, 0xad,
	0x72, 0x29, 0xb7, 0x12, 0x08, 0x6a, 0x2b, 0x85, 0xe6, 0x38, 0xf5, 0xbc, 0xdc, 0x4a, 0x0e, 0x3a,
	0x8e, 0xfe, 0x2f, 0x0d, 0xd0, 0x6b, 0x5c, 0xfa, 0x1b, 0x2c, 0xc4, 0x96, 0x4b, 0xbc, 0xce, 0xc6,
	0x9e, 0x15, 0xa0, 0xbb, 0x90, 0x67, 0x3d, 0x93, 0x38, 0x82, 0x2f, 0xe5, 0xd6, 0xcb, 0x87, 0x07,
	0x8d, 0xdc, 0x66, 0x6f, 0x75, 0xe5, 0xf1, 0x41, 0xe3, 0x4a, 0x87, 0xb0, 0xae, 0x25, 0x29, 0xe8,
	0x8b, 0x80, 0x7f, 0x79, 0xbe, 0x83, 0x63, 0x0d, 0xe1, 0x93, 0x8d, 0x1c, 0xeb, 0xad, 0x3a, 0xe8,
	0x32, 0x94, 0x88, 0xc7, 0x70, 0xb8, 0x6b, 0x75, 0x05, 0xdf, 0x72, 0x46, 0xd2, 0xe6, 0x63, 0xef,
	0x46, 0x96, 0xc7, 0x08, 0xdb, 0x17, 0x5c, 0xc8, 0x19, 0x49, 0x1b, 0x5d, 0x84, 0xbc, 0xed, 0x47,
	0x9e, 0xe4, 0x40, 0xce, 0x90, 0x0d, 0xd4, 0x80, 0x4a, 0xd7, 0xa2, 0xcc, 0xdc, 0xc1, 0xa4, 0xb3,
	0xc3, 0xc4, 0x79, 0x34, 0x03, 0x78, 0xd7, 0xeb, 0xa2, 0x07, 0x19, 0x50, 0x65, 0xa1, 0xe5, 0x60,
	0x93, 0x59, 0x61, 0x07, 0xb3, 0x7a, 0x21, 0x1d, 0xff, 0x2a, 0x02, 0x64, 0x53, 0x60, 0xa0, 0x6b,
	0x50, 0x74, 0x70, 0xe0, 0x53, 0xc2, 0xea, 0x45, 0xa1, 0x28, 0xd5, 0x58, 0x51, 0x96, 0x7d, 0xe2,
	0x29, 0x3d, 0x89, 0xa7, 0x20, 0x1d, 0xb2, 0xc4, 0xab, 0x97, 0x8e, 0x9d, 0x98, 0x25, 0x1e, 0xfa,
	0x2a, 0x68, 0x7e, 0xc4, 0xea, 0xe5, 0x63, 0x27, 0xf1, 0x61, 0xf4, 0x1c, 0x54, 0xb7, 0x2d, 0xd2,
	0xc5, 0x8e, 0x49, 0xf7, 0xac, 0x80, 0xd6, 0x61, 0x4e, 0x9b, 0xcf, 0x19, 0x15, 0xd9, 0xc7, 0x05,
	0x45, 0xd1, 0x02, 0x5c, 0x18, 0x98, 0x62, 0x86, 0xd8, 0xa2, 0xbe, 0x47, 0xeb, 0x95, 0x39, 0x6d,
	0xbe, 0x6c, 0xcc, 0xf4, 0x67, 0x1a, 0x72, 0x40, 0xff, 0x30, 0x0f, 0x65, 0x29, 0x70, 0x2e, 0xe7,
	0x17, 0x21, 0xc7, 0x0d, 0xf4, 0x24, 0xf5, 0x17, 0x13, 0xd0, 0x3a, 0x54, 0x04, 0xbe, 0x62, 0x6a,
	0x4a, 0xfd, 0x07, 0x8e, 0xa1, 0x78, 0x7a, 0x0f, 0xca, 0x02, 0x91, 0x76, 0x49, 0x20, 0x64, 0x9f,
	0x46, 0xc9, 0x39, 0xc2, 0x46, 0x97, 0x04, 0x68, 0x13, 0xa6, 0xba, 0xe4, 0xdd, 0x88, 0x38, 0x84,
	0xed, 0x9b, 0xdb, 0x18, 0xa7, 0x35, 0x9b, 0x6a, 0x82, 0x72, 0x1b, 0x63, 0xe4, 0xc0, 0xa5, 0x21,
	0x54, 0x93, 0x78, 0xa6, 0xb0, 0x52, 0xa1, 0x77, 0x29, 0xe0, 0x2f, 0x0c, 0xc2, 0xaf, 0x7a, 0xcb,
	0x1c, 0x0b, 0x7d, 0x0d, 0xf2, 0xc4, 0x33, 0x59, 0x4f, 0xa8, 0x6a, 0xe5, 0x26, 0x2c, 0x24, 0x36,
	0x14, 0x8b, 0x80, 0x78, 0x9b, 0x3d, 0x74, 0x05, 0x8a, 0x7e, 0xc4, 0x4c, 0xd6, 0xa3, 0x4a, 0x09,
	0x47, 0x27, 0x16, 0xfc, 0x88, 0x6d, 0xf6, 0x28, 0x5a, 0x02, 0xc0, 0x2e, 0x61, 0xa6, 0xf4, 0x6d,
	0xc7, 0x6b, 0x62, 0x99, 0xcf, 0x12, 0xc2, 0x16, 0x02, 0xde, 0xf7, 0xd8, 0x8e, 0x19, 0x79, 0x84,
	0x51, 0xa1, 0x98, 0xa9, 0x04, 0xcc, 0x31, 0x1e, 0x70, 0x08, 0xf4, 0x0a, 0x3c, 0x4d, 0x63, 0xa7,
	0x22, 0x95, 0x33, 0x31, 0x75, 0x10, 0x16, 0xfd, 0x14, 0x1d, 0xf4, 0x39, 0x6f, 0xc5, 0x76, 0x7f,
	0x03, 0x2e, 0x1e, 0x59, 0x27, 0xdd, 0x40, 0x45, 0x2c, 0x42, 0x43, 0x8b, 0x96, 0xf9, 0x88, 0xfe,
	0xb3, 0x1c, 0xcc, 0x08, 0x9d, 0x6e, 0x6e, 0x6f, 0x93, 0x2e, 0xb1, 0x18, 0xe6, 0xc2, 0x9b, 0xa4,
	0x0f, 0x43, 0x90, 0x73, 0xb1, 0xeb, 0x4b, 0xbd, 0x37, 0xc4, 0x37, 0xf7, 0x5d, 0x62, 0x85, 0xe5,
	0x62, 0xa9, 0xbf, 0x46, 0xd2, 0x46, 0x0f, 0x60, 0x2a, 0x71, 0xef, 0x21, 0xa6, 0x54, 0xa9, 0xe3,
	0x8d, 0xc7, 0x07, 0x8d, 0x6b, 0x63, 0xed, 0xdd, 0x94, 0xeb, 0x8c, 0x6a, 0x1c, 0x14, 0x78, 0xab,
	0x1f, 0xae, 0xf2, 0x9f, 0x1a, 0xae, 0x0c, 0xa8, 0x76, 0x42, 0x9f, 0x52, 0xd3, 0x72, 0x05, 0xf7,
	0xd2, 0xba, 0x41, 0x01, 0xd2, 0x14, 0x18, 0x68, 0x0e, 0xaa, 0xdc, 0x08, 0xda, 0x01, 0x35, 0x19,
	0xb1, 0x1f, 0x09, 0x35, 0xcc, 0x19, 0xb0, 0x8d, 0x71, 0x2b, 0xa0, 0x9b, 0xc4, 0x7e, 0x84, 0xee,
	0x03, 0x6f, 0xc5, 0x7b, 0x96, 0xd2, 0xed, 0x59, 0xde, 0xc6, 0x58, 0xed, 0x78, 0x09, 0x0a, 0x81,
	0x15, 0x62, 0x4f, 0x7a, 0xca, 0xb2, 0xa1, 0x5a, 0x68, 0x16, 0x2a, 0x34, 0x6a, 0x9b, 0x8a, 0x1a,
	0xa5, 0x4f, 0x65, 0x1a, 0xb5, 0x6f, 0x0b, 0x5a, 0xf4, 0x5f, 0xe7, 0x63, 0x8d, 0x70, 0x9c, 0x7b,
	0xb1, 0xc9, 0x8d, 0xef, 0xed, 0xb6, 0xe0, 0x7c, 0x10, 0xfa, 0xbb, 0xc4, 0xc1, 0xa1, 0xb2, 0x87,
	0x94, 0x0e, 0x6f, 0x2a, 0x86, 0x91, 0x26, 0x31, 0xa2, 0x16, 0xda, 0x44, 0xd4, 0xc2, 0x80, 0x6a,
	0x9c, 0x9a, 0x24, 0x01, 0x33, 0x8d, 0xac, 0x55, 0x76, 0x22, 0x38, 0x6f, 0x40, 0x35, 0xce, 0x41,
	0x04, 0x66, 0x4a, 0x87, 0x57, 0x51, 0x69, 0x88, 0xc0, 0x7c, 0x1b, 0xe4, 0x16, 0xa6, 0xb4, 0x4b,
	0xa9, 0x92, 0xdf, 0x38, 0x3c, 0x68, 0x94, 0x8c, 0xc8, 0xc3, 0xa7, 0xb7, 0x4d, 0x99, 0x42, 0x6d,
	0x72, 0x03, 0x7d, 0x08, 0x72, 0x27, 0x05, 0x5d, 0x14, 0xd0, 0xdf, 0x3c, 0x3c, 0x68, 0x94, 0x85,
	0x74, 0x53, 0x60, 0x5b, 0x6a, 0x9d, 0xc3, 0xa5, 0x96, 0x24, 0x50, 0x42, 0x6a, 0xa5, 0xb4, 0x52,
	0x8b, 0xd3, 0x2e, 0xde, 0xd2, 0xdf, 0xcb, 0xc1, 0x94, 0xd0, 0xd1, 0xef, 0x10, 0xb6, 0xe3, 0x84,
	0xd6, 0xde, 0xe7, 0xaf, 0x9f, 0xcf, 0x41, 0xb5, 0x6d, 0x51, 0x42, 0xcd, 0xc0, 0x27, 0x1e, 0x93,
	0xea, 0xa9, 0x19, 0x15, 0xd1, 0xb7, 0x2e, 0xba, 0x64, 0x6e, 0xba, 0xef, 0xba, 0x98, 0x85, 0xfb,
	0x42, 0xd1, 0xaa, 0xad, 0x05, 0xb5, 0xeb, 0x0b, 0x63, 0xec, 0xba, 0x82, 0x6d, 0xa3, 0x0f, 0xd0,
	0x0f, 0x7d, 0xf9, 0x13, 0x43, 0xdf, 0xfd, 0xa1, 0x78, 0x96, 0xd2, 0x95, 0x0d, 0x04, 0xbb, 0x18,
	0x4f, 0xc6, 0xf2, 0xe2, 0x19, 0xf0, 0x64, 0x04, 0x37, 0xe1, 0x02, 0x71, 0x03, 0xb3, 0xcb, 0xfd,
	0x2d, 0xbf, 0x64, 0x60, 0x9b, 0x11, 0xdf, 0x4b, 0xeb, 0xff, 0x66, 0x88, 0x1b, 0xdc, 0xf3, 0x29,
	0x5d, 0x4f, 0x90, 0xf4, 0x9f, 0xe4, 0xe1, 0x29, 0xa1, 0x2b, 0xeb, 0xd8, 0x73, 0x88, 0xd7, 0x49,
	0xe1, 0xd3, 0xbe, 0x0d, 0xd5, 0x40, 0x2e, 0x36, 0xf9, 0x5e, 0x42, 0x63, 0xce, 0xdf, 0x7c, 0x76,
	0x41, 0x6e, 0x7c, 0x14, 0x77, 0x73, 0x3f, 0xc0, 0x46, 0x45, 0x2d, 0xe0, 0x8d, 0x2f, 0x93, 0xef,
	0x1a, 0x31, 0xd8, 0xfc, 0x24, 0x0c, 0x76, 0xc4, 0x25, 0x16, 0x26, 0xef, 0x12, 0x8b, 0x9f, 0x9d,
	0x4b, 0x2c, 0x4d, 0xd0, 0x25, 0xea, 0xef, 0x40, 0x45, 0xa8, 0xe3, 0x8a, 0xef, 0x59, 0x0c, 0x8f,
	0xaf, 0x84, 0x89, 0xbd, 0x67, 0x4f, 0xb2, 0x77, 0xdd, 0x54, 0x77, 0x14, 0x7e, 0x4d, 0x1f, 0x1f,
	0xfc, 0x0a, 0x14, 0x36, 0x98, 0xc5, 0x22, 0xaa, 0x74, 0x7b, 0x26, 0xd6, 0x6d, 0xdf, 0xef, 0xca,
	0x01, 0x43, 0x4d, 0xd0, 0xef, 0xc9, 0x12, 0x00, 0xbf, 0x1e, 0x9f, 0xa2, 0x04, 0x70, 0x09, 0x0a,
	0x4a, 0xf4, 0x59, 0xe1, 0x18, 0x55, 0x4b, 0xff, 0x55, 0x06, 0xce, 0x0b, 0x7a, 0x0d, 0xbc, 0x67,
	0x85, 0x0e, 0xdd, 0x5a, 0xe2, 0xe9, 0x74, 0xdb, 0xf7, 0x1c, 0x33, 0x14, 0x3d, 0x2a, 0x05, 0x3d,
	0x7d, 0x3a, 0xcd, 0x31, 0x24, 0x28, 0xba, 0x05, 0x55, 0x7e, 0x4a, 0x85, 0xc8, 0xcf, 0xa8, 0xcd,
	0x57, 0x6e, 0x9e, 0x1f, 0x38, 0x63, 0xd3, 0x8d, 0xe9, 0xad, 0xf0, 0x99, 0x8a, 0x18, 0xfd, 0xc3,
	0x2c, 0x54, 0x07, 0xa9, 0xfb, 0x02, 0xd1, 0x86, 0xbe, 0x0b, 0x33, 0x52, 0xfd, 0x07, 0x96, 0xa7,
	0xbd, 0x0c, 0x4e, 0x0b, 0xa4, 0xf5, 0x04, 0x1d, 0xbd, 0x0d, 0x35, 0xae, 0xc7, 0xe6, 0x76, 0xd4,
	0x3f, 0x6c, 0x4a, 0xf7, 0x72, 0x9e, 0x03, 0xdd, 0x8e, 0xe2, 0x03, 0xeb, 0xdf, 0xcf, 0x28, 0x03,
	0x30, 0x30, 0x47, 0xe7, 0xf7, 0x03, 0xdb, 0x77, 0xb0, 0xe0, 0xe5, 0x94, 0x21, 0xbe, 0xb9, 0xb6,
	0xc8, 0xdb, 0xb8, 0xba, 0x35, 0xa8, 0x56, 0xdf, 0x06, 0xb4, 0x13, 0x63, 0xde, 0xf3, 0xa0, 0xc5,
	0xf7, 0xd8, 0xca, 0xcd, 0x4a, 0x3c, 0x89, 0xe7, 0xb7, 0xaa, 0x40, 0xb0, 0x8d, 0xb1, 0xfe, 0x5e,
	0x46, 0x59, 0x4a, 0xcb, 0xf7, 0x1c, 0x74, 0x27, 0xd1, 0xcf, 0x94, 0x32, 0x55, 0xcb, 0xd1, 0x35,
	0x28, 0x0b, 0x0d, 0x19, 0x08, 0x14, 0xd3, 0x4a, 0x98, 0x7c, 0x23, 0x11, 0x1c, 0x4a, 0x6d, 0xf5,
	0xc5, 0x0f, 0xc4, 0x5d, 0x8c, 0x77, 0xfc, 0x81, 0x58, 0x6f, 0xd5, 0xd3, 0x3f, 0xca, 0xa8, 0x7c,
	0x87, 0x43, 0x6c, 0x2d, 0xdd, 0x78, 0xf9, 0x8b, 0x4d, 0x6f, 0xdf, 0x31, 0xe4, 0x3e, 0xcd, 0x31,
	0xe8, 0xff, 0xc8, 0x40, 0xf1, 0x8e, 0x45, 0xd7, 0xa5, 0x17, 0xfa, 0x9c, 0x4a, 0x8a, 0x43, 0x55,
	0x43, 0xed, 0xac, 0x55, 0xc3, 0xa1, 0xea, 0x9b, 0xa6, 0xaa, 0x6f, 0xfa, 0x2b, 0x50, 0x12, 0x22,
	0xbc, 0x63, 0x51, 0x74, 0x15, 0xf2, 0xdc, 0x6a, 0x69, 0x3d, 0x33, 0x64, 0xed, 0x8a, 0x0f, 0xf1,
	0x49, 0xc5, 0x14, 0xfd, 0x07, 0x99, 0xc4, 0x07, 0x89, 0xf2, 0x2e, 0x5a, 0x87, 0x0b, 0x9f, 0x50,
	0xe9, 0x55, 0x3c, 0x7b, 0x46, 0x41, 0xa9, 0xc9, 0xcb, 0xfd, 0x09, 0x0a, 0x15, 0x85, 0x23, 0x23,
	0xe3, 0x86, 0x96, 0x3b, 0x70, 0x49, 0x96, 0xbf, 0xec, 0x1d, 0xec, 0x44, 0x5d, 0xec, 0xbc, 0x19,
	0xb1, 0xb6, 0xcf, 0x6d, 0xf8, 0x3a, 0x14, 0x64, 0x7d, 0x45, 0x51, 0x51, 0x53, 0x54, 0x6c, 0xf6,
	0xde, 0x8c, 0xd8, 0x2a, 0xc3, 0x6e, 0x7c, 0x24, 0x51, 0x64, 0xd1, 0x97, 0x95, 0x36, 0x6f, 0x60,
	0x3b, 0x0a, 0x79, 0x26, 0x56, 0x03, 0xcd, 0xa5, 0x1d, 0xa9, 0xca, 0x06, 0xff, 0x44, 0x73, 0x90,
	0x3d, 0x81, 0x9e, 0x2c, 0xeb, 0xe9, 0x1e, 0x80, 0x04, 0xe9, 0x5a, 0x74, 0x67, 0xfc, 0x48, 0x77,
	0x0b, 0xaa, 0x94, 0xaf, 0x30, 0x93, 0x70, 0x74, 0x82, 0xbf, 0x15, 0x33, 0x65, 0xba, 0xa1, 0xff,
	0x21, 0x0b, 0x17, 0xfa, 0x1b, 0xf6, 0xb3, 0xc8, 0x77, 0x60, 0x86, 0x87, 0x7b, 0x53, 0x58, 0x51,
	0x9c, 0x35, 0x65, 0x44, 0x76, 0xbf, 0xf4, 0xf8, 0xa0, 0x71, 0x7d, 0x0c, 0xfd, 0x69, 0xda, 0x76,
	0x9c, 0x36, 0x4d, 0x73, 0x2c, 0x6e, 0x78, 0x23, 0x75, 0x8b, 0xec, 0xa7, 0xda, 0xc4, 0x5d, 0x28,
	0x9e, 0x35, 0xc1, 0x8c, 0x01, 0xd0, 0x5d, 0x28, 0x75, 0x03, 0x75, 0x41, 0x4a, 0xe9, 0xf8, 0x8b,
	0xdd, 0x40, 0x5c, 0x8d, 0xf4, 0x5f, 0xc4, 0x1e, 0xff, 0xb5, 0x30, 0xb4, 0x98, 0x35, 0xd1, 0xea,
	0xd2, 0x2b, 0xb1, 0x25, 0x8d, 0xca, 0x71, 0xcd, 0x77, 0x5a, 0x35, 0x4e, 0xf4, 0xef, 0xff, 0xda,
	0x28, 0xa9, 0x0e, 0x1a, 0x5b, 0xd5, 0x9f, 0x32, 0xca, 0x1c, 0x27, 0x5d, 0xee, 0x52, 0xb1, 0x27,
	0x7b, 0x52, 0xec, 0x39, 0x5a, 0x31, 0xd4, 0xce, 0x5c, 0x31, 0xd4, 0xbf, 0x17, 0x47, 0x88, 0xc4,
	0x26, 0xdf, 0x82, 0x92, 0x30, 0xea, 0xfe, 0xb9, 0x6e, 0x1d, 0x1e, 0x34, 0x0a, 0xab, 0xde, 0xe9,
	0x4f, 0x56, 0xe0, 0xe6, 0xbf, 0xea, 0x8c, 0x61, 0x94, 0xbf, 0xcc, 0xa8, 0xcb, 0xd6, 0x26, 0xa5,
	0x6f, 0xe0, 0xfd, 0x0e, 0xf6, 0x36, 0x22, 0xdb, 0xe6, 0x0a, 0xf5, 0x3a, 0x14, 0x83, 0xa8, 0x6d,
	0x3e, 0xc2, 0xfb, 0x71, 0xc4, 0x7a, 0x7c, 0xd0, 0x78, 0x69, 0x2c, 0x1a, 0xd6, 0xa3, 0xf6, 0x1b,
	0x78, 0xdf, 0x28, 0x04, 0xe2, 0x3f, 0xaa, 0x43, 0xd1, 0xc5, 0x6e, 0x1b, 0x87, 0x52, 0xe8, 0x65,
	0x23, 0x6e, 0xf2, 0xb4, 0x41, 0xbd, 0x6d, 0xc8, 0xdb, 0xb7, 0x6a, 0xe9, 0xbf, 0x1d, 0xa1, 0xea,
	0xb6, 0x45, 0xba, 0x51, 0x88, 0x51, 0x03, 0xc4, 0x8b, 0x80, 0xaa, 0xfd, 0x2b, 0x07, 0x04, 0xbc,
	0x4b, 0x16, 0xfd, 0xd1, 0x57, 0x00, 0x08, 0xe5, 0x62, 0xb2, 0x2d, 0x2a, 0x6d, 0xb0, 0x64, 0x94,
	0x09, 0x7d, 0x20, 0x3b, 0xf8, 0xfa, 0x76, 0xd7, 0x72, 0xb1, 0xc9, 0xe9, 0xe5, 0x82, 0xe4, 0xf4,
	0x80, 0xe8, 0xba, 0xcf, 0x7b, 0x78, 0x2c, 0x08, 0xb9, 0x38, 0xa4, 0x11, 0x19, 0xb2, 0x31, 0x40,
	0x68, 0x7e, 0x88, 0xd0, 0x9f, 0x66, 0xe0, 0xe2, 0x30, 0xa1, 0x6b, 0x98, 0x85, 0xc4, 0x9e, 0x20,
	0xf7, 0xae, 0x01, 0x72, 0xb1, 0x43, 0x2c, 0xcf, 0x74, 0xa2, 0xd0, 0xe2, 0x37, 0x64, 0xd3, 0xa5,
	0x2a, 0x29, 0xaf, 0xc9, 0x91, 0x15, 0x35, 0xb0, 0x26, 0x4c, 0x77, 0x90, 0x73, 0x94, 0x74, 0x62,
	0x8a, 0x26, 0x69, 0x33, 0xa7, 0xa3, 0xe9, 0x37, 0x19, 0x98, 0xee, 0x3b, 0x62, 0x51, 0x5b, 0x41,
	0x9b, 0x50, 0x15, 0x4e, 0xf8, 0xcc, 0xfe, 0xb7, 0xc2, 0x61, 0x62, 0xdf, 0xfb, 0x5c, 0x1c, 0x2b,
	0x54, 0x4d, 0x47, 0x52, 0x24, 0xa3, 0x82, 0xaa, 0xe9, 0xf4, 0x33, 0x55, 0x6d, 0x30, 0x53, 0xd5,
	0x77, 0xe0, 0xe9, 0xe4, 0x1a, 0xd6, 0xb2, 0xba, 0x96, 0x67, 0xe3, 0xe5, 0x1d, 0xcb, 0xeb, 0x60,
	0x07, 0xbd, 0x0c, 0x22, 0x8f, 0x37, 0x6d, 0xd1, 0x56, 0x11, 0xeb, 0xa8, 0xe3, 0x92, 0x26, 0x05,
	0x7c, 0xa2, 0x5c, 0x77, 0x5c, 0x4e, 0xac, 0xff, 0x2e, 0xab, 0xbc, 0xeb, 0xc6, 0x1e, 0x61, 0xf6,
	0x0e, 0x5a, 0x07, 0x60, 0xfe, 0xd9, 0x19, 0x51, 0x66, 0x49, 0x9d, 0x61, 0x03, 0xaa, 0xdb, 0xa1,
	0xef, 0x26, 0x98, 0xd9, 0x94, 0xc1, 0xa5, 0xc2, 0x51, 0x62, 0xd0, 0x17, 0x20, 0xd7, 0x8e, 0xc2,
	0x38, 0x91, 0xfc, 0xa4, 0x17, 0x16, 0x31, 0xde, 0xd7, 0xb3, 0xdc, 0x99, 0xf5, 0x4c, 0xff, 0x77,
	0x56, 0x5d, 0x36, 0x25, 0xab, 0xb6, 0x5e, 0xbd, 0xf5, 0x84, 0x5b, 0xc7, 0x5b, 0xe5, 0x32, 0xe4,
	0x5c, 0x92, 0xbe, 0x7c, 0x2d, 0x16, 0xeb, 0x7f, 0xd4, 0xd4, 0x6b, 0xc2, 0x5a, 0xf3, 0xed, 0xe6,
	0x7d, 0xcb, 0xc5, 0x5b, 0x4b, 0x4b, 0x4b, 0xfc, 0xce, 0x27, 0xde, 0x7e, 0xa4, 0xbf, 0x15, 0xdf,
	0x68, 0x05, 0xf2, 0x82, 0x24, 0xc5, 0xb0, 0x85, 0xc7, 0x07, 0x8d, 0xab, 0x63, 0x91, 0xbc, 0xcc,
	0x7b, 0x0d, 0xb9, 0x78, 0xa2, 0x39, 0xd0, 0x43, 0xa8, 0x85, 0xb8, 0x43, 0x28, 0x53, 0x3e, 0xe9,
	0x0c, 0x6f, 0xa3, 0xd3, 0x83, 0x40, 0x32, 0xe5, 0x28, 0x89, 0xbb, 0x35, 0xbf, 0x70, 0xa4, 0x64,
	0x70, 0x91, 0x03, 0xf0, 0xfb, 0xc6, 0x25, 0x28, 0xe0, 0x5e, 0x40, 0x42, 0x2c, 0xca, 0x6a, 0x9a,
	0xa1, 0x5a, 0xe8, 0x0e, 0xe4, 0xfd, 0x3d, 0x0f, 0x87, 0xa2, 0x34, 0x96, 0x4a, 0xad, 0xe5, 0x7a,
	0xfd, 0x9f, 0x71, 0xb9, 0x3d, 0x16, 0xe2, 0x13, 0x01, 0x7e, 0xa9, 0x04, 0x88, 0x9e, 0x87, 0x29,
	0x2b, 0x7e, 0xdf, 0x15, 0xaf, 0x7e, 0x25, 0xb1, 0x4f, 0x35, 0xe9, 0x6c, 0x05, 0x14, 0xbd, 0x04,
	0x33, 0x34, 0x6a, 0xf7, 0xe7, 0x09, 0x01, 0x97, 0x45, 0x46, 0x53, 0x1b, 0x1c, 0x10, 0x0a, 0xf0,
	0x10, 0x86, 0xfa, 0xd4, 0x53, 0xa2, 0x96, 0x8a, 0xb5, 0x83, 0x40, 0xad, 0x80, 0xea, 0xb7, 0x92,
	0xeb, 0x21, 0x5b, 0x23, 0x2e, 0x09, 0xf9, 0xf5, 0x30, 0xc9, 0x7c, 0x0c, 0xfe, 0xc9, 0xd3, 0xaa,
	0x5d, 0xab, 0x1b, 0x61, 0x15, 0x0b, 0x65, 0x43, 0x7f, 0xa0, 0x7c, 0xcd, 0x06, 0x66, 0x3c, 0xfb,
	0x3a, 0xd5, 0x62, 0x9e, 0x56, 0x0e, 0x29, 0x5e, 0xa2, 0x46, 0xfa, 0x9f, 0xb3, 0x2a, 0x09, 0x5a,
	0x6e, 0x2e, 0x37, 0xdf, 0xe4, 0x11, 0x7a, 0x45, 0xfd, 0x5c, 0x65, 0xeb, 0x68, 0x61, 0x3f, 0x75,
	0x00, 0x39, 0xb9, 0xb2, 0x9f, 0x9d, 0x40, 0x65, 0xff, 0x35, 0xc8, 0x9f, 0xe9, 0xb6, 0x21, 0x57,
	0xa3, 0xd6, 0x70, 0x84, 0xb9, 0x9e, 0x26, 0x0e, 0xff, 0x3d, 0x07, 0x97, 0x87, 0x19, 0x1a, 0xbf,
	0xe3, 0x6d, 0x2d, 0x2d, 0xbd, 0xfa, 0x99, 0x71, 0xf5, 0xe8, 0x13, 0x5d, 0x76, 0xf4, 0x89, 0xee,
	0x28, 0xe3, 0xb5, 0x49, 0x32, 0x3e, 0x37, 0x19, 0xc6, 0xe7, 0x53, 0x33, 0x1e, 0x2d, 0xc0, 0x85,
	0x01, 0x93, 0x95, 0xbc, 0x60, 0x54, 0x79, 0x9d, 0x99, 0xbe, 0x11, 0x0a, 0x8e, 0x30, 0xe1, 0x40,
	0xfb, 0xf3, 0x15, 0x4b, 0x52, 0x3e, 0xf9, 0x4d, 0x27, 0x40, 0x8a, 0x2d, 0xef, 0xc0, 0xcc, 0x00,
	0xf6, 0x19, 0x9f, 0x87, 0xfb, 0x64, 0xc6, 0x4f, 0xc4, 0xff, 0xd1, 0x54, 0xb5, 0x6a, 0x44, 0xc7,
	0x9e, 0xe8, 0xd7, 0xff, 0x83, 0x7e, 0xe9, 0x3f, 0xd4, 0xa0, 0x2e, 0xaf, 0xae, 0xa1, 0xe5, 0xe0,
	0xa6, 0x2d, 0xaa, 0xb0, 0xb1, 0xe3, 0x9e, 0x58, 0xf9, 0xfc, 0x14, 0xe5, 0xb9, 0x91, 0xa7, 0x55,
	0x6d, 0x22, 0x4f, 0xab, 0x9f, 0xd1, 0xef, 0xa5, 0xee, 0x0e, 0xab, 0xc3, 0x99, 0xee, 0x5d, 0x3f,
	0xd2, 0xe0, 0x99, 0x11, 0x51, 0x24, 0xe6, 0xf8, 0x44, 0x16, 0xff, 0x43, 0x59, 0x5c, 0xbd, 0x0e,
	0x17, 0x3f, 0xe9, 0x07, 0x0b, 0xa8, 0x08, 0x9a, 0xe5, 0x38, 0xb5, 0x73, 0xa8, 0x0a, 0xa5, 0x3d,
	0x25, 0x9a, 0x5a, 0xe6, 0x6a, 0x1b, 0x4a, 0xf1, 0x33, 0x10, 0x9a, 0x52, 0x4f, 0x45, 0x81, 0x45,
	0xf8, 0xc4, 0x19, 0x98, 0x52, 0x6f, 0xa1, 0x2c, 0x0a, 0x3d, 0xec, 0xd4, 0x32, 0x68, 0x7a, 0xe8,
	0x79, 0xb4, 0x96, 0x4d, 0x96, 0xd8, 0x3e, 0x65, 0x35, 0x0d, 0x5d, 0x84, 0xda, 0xc0, 0xb8, 0x04,
	0xca, 0xb5, 0x56, 0xdf, 0x3f, 0x9c, 0xcd, 0x7c, 0x70, 0x38, 0x9b, 0xf9, 0xdb, 0xe1, 0x6c, 0xe6,
	0xe7, 0x1f, 0xcf, 0x9e, 0xfb, 0xe0, 0xe3, 0xd9, 0x73, 0x1f, 0x7d, 0x3c, 0x7b, 0xee, 0xe1, 0xe2,
	0xc9, 0xa7, 0x1b, 0xf9, 0x21, 0x7b, 0xbb, 0x20, 0x7e, 0xa7, 0xfe, 0xf5, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0xa7, 0x89, 0xd1, 0x91, 0xbb, 0x2f, 0x00, 0x00,
}

func (m *PoolMod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetAdd {
		i--
		if m.AssetAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.CacaoAdd {
		i--
		if m.CacaoAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CacaoAmt.Size()
		i -= size
		if _, err := m.CacaoAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventStreamingSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamingSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStreamingSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedSwapReasons) > 0 {
		for iNdEx := len(m.FailedSwapReasons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedSwapReasons[iNdEx])
			copy(dAtA[i:], m.FailedSwapReasons[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailedSwapReasons[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FailedSwaps) > 0 {
		dAtA3 := make([]byte, len(m.FailedSwaps)*10)
		var j2 int
		for _, num := range m.FailedSwaps {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTypeEvents(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.In.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TradeTarget.Size()
		i -= size
		if _, err := m.TradeTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LastHeight != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamingSwapCount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapCount))
		i--
		dAtA[i] = 0x58
	}
	if m.StreamingSwapQuantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapQuantity))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.EmitAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.OutTxs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityFeeInCacao.Size()
		i -= size
		if _, err := m.LiquidityFeeInCacao.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LiquidityFee.Size()
		i -= size
		if _, err := m.LiquidityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwapSlip.Size()
		i -= size
		if _, err := m.SwapSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapTarget.Size()
		i -= size
		if _, err := m.SwapTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventAffiliateFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAffiliateFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAffiliateFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubFeeBps != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SubFeeBps))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Parent) > 0 {
		i -= len(m.Parent)
		copy(dAtA[i:], m.Parent)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Parent)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size := m.FeeAmount.Size()
		i -= size
		if _, err := m.FeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.FeeBpsTick != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.FeeBpsTick))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.GrossAmount.Size()
		i -= size
		if _, err := m.GrossAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mayaname) > 0 {
		i -= len(m.Mayaname)
		copy(dAtA[i:], m.Mayaname)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Mayaname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.CacaoAmount.Size()
		i -= size
		if _, err := m.CacaoAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ImpLossProtection.Size()
		i -= size
		if _, err := m.ImpLossProtection.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.EmitCacao.Size()
		i -= size
		if _, err := m.EmitCacao.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.EmitAsset.Size()
		i -= size
		if _, err := m.EmitAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Asymmetry.Size()
		i -= size
		if _, err := m.Asymmetry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPendingLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPendingLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPendingLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.CacaoAmount.Size()
		i -= size
		if _, err := m.CacaoAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PendingType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.PendingType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDonate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDonate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDonate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewardsV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewardsV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewardsV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MayaFundReward.Size()
		i -= size
		if _, err := m.MayaFundReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CacaoPoolReward.Size()
		i -= size
		if _, err := m.CacaoPoolReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRefund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRefund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRefund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventBondV105) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBondV105) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBondV105) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GasPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CacaoAmt.Size()
		i -= size
		if _, err := m.CacaoAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReserveContributor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventScheduledOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventScheduledOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventScheduledOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashAmount) > 0 {
		for iNdEx := len(m.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSlashLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LpUnits.Size()
		i -= size
		if _, err := m.LpUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.NodeBondAddress) > 0 {
		i -= len(m.NodeBondAddress)
		copy(dAtA[i:], m.NodeBondAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeBondAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventErrata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventErrata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventErrata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InTxID) > 0 {
		i -= len(m.InTxID)
		copy(dAtA[i:], m.InTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.InTxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenSuccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenSuccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Round) > 0 {
		i -= len(m.Round)
		copy(dAtA[i:], m.Round)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Round)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BlameNodes) > 0 {
		for iNdEx := len(m.BlameNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlameNodes[iNdEx])
			copy(dAtA[i:], m.BlameNodes[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BlameNodes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsUnicast {
		i--
		if m.IsUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FailReason) > 0 {
		i -= len(m.FailReason)
		copy(dAtA[i:], m.FailReason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailReason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeysignMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeysignMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeysignMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlashPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SlashPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolBalanceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolBalanceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolBalanceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PoolChange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Burn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwitchV87) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitchV87) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitchV87) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Mint.Size()
		i -= size
		if _, err := m.Mint.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Burn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMAYANameV111) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMAYANameV111) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMAYANameV111) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Expire != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.FundAmt.Size()
		i -= size
		if _, err := m.FundAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMAYAName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMAYAName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMAYAName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaffiliateBps) > 0 {
		for iNdEx := len(m.SubaffiliateBps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.SubaffiliateBps[iNdEx].Size()
				i -= size
				if _, err := m.SubaffiliateBps[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.SubaffiliateName) > 0 {
		for iNdEx := len(m.SubaffiliateName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaffiliateName[iNdEx])
			copy(dAtA[i:], m.SubaffiliateName[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.SubaffiliateName[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AffiliateBps != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.AffiliateBps))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Expire != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.FundAmt.Size()
		i -= size
		if _, err := m.FundAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetNodeMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetNodeMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetNodeMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCACAOPoolDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCACAOPoolDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCACAOPoolDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CacaoAmount.Size()
		i -= size
		if _, err := m.CacaoAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCACAOPoolWithdrawV118) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCACAOPoolWithdrawV118) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCACAOPoolWithdrawV118) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AffiliateAddress) > 0 {
		i -= len(m.AffiliateAddress)
		copy(dAtA[i:], m.AffiliateAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AffiliateAddress)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.AffiliateAmount.Size()
		i -= size
		if _, err := m.AffiliateAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.AffiliateBasisPts != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.AffiliateBasisPts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CacaoAmount.Size()
		i -= size
		if _, err := m.CacaoAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCACAOPoolWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCACAOPoolWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCACAOPoolWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AffiliateAmount.Size()
		i -= size
		if _, err := m.AffiliateAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.AffiliateBasisPts != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.AffiliateBasisPts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CacaoAmount.Size()
		i -= size
		if _, err := m.CacaoAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CacaoAddress) > 0 {
		i -= len(m.CacaoAddress)
		copy(dAtA[i:], m.CacaoAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.CacaoAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTypeEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypeEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolMod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CacaoAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.CacaoAdd {
		n += 2
	}
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.AssetAdd {
		n += 2
	}
	return n
}

func (m *EventStreamingSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovTypeEvents(uint64(m.Interval))
	}
	if m.Quantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.Quantity))
	}
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	if m.LastHeight != 0 {
		n += 1 + sovTypeEvents(uint64(m.LastHeight))
	}
	l = m.TradeTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Deposit.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.In.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Out.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.FailedSwaps) > 0 {
		l = 0
		for _, e := range m.FailedSwaps {
			l += sovTypeEvents(uint64(e))
		}
		n += 1 + sovTypeEvents(uint64(l)) + l
	}
	if len(m.FailedSwapReasons) > 0 {
		for _, s := range m.FailedSwapReasons {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFeeInCacao.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.OutTxs.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.StreamingSwapQuantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapQuantity))
	}
	if m.StreamingSwapCount != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapCount))
	}
	return n
}

func (m *EventAffiliateFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Mayaname)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.GrossAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.FeeBpsTick != 0 {
		n += 1 + sovTypeEvents(uint64(m.FeeBpsTick))
	}
	l = m.FeeAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SubFeeBps != 0 {
		n += 1 + sovTypeEvents(uint64(m.SubFeeBps))
	}
	return n
}

func (m *EventAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.CacaoAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.Asymmetry.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitCacao.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ImpLossProtection.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPendingLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.PendingType != 0 {
		n += 1 + sovTypeEvents(uint64(m.PendingType))
	}
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.CacaoAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventDonate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypeEvents(uint64(m.Status))
	}
	return n
}

func (m *PoolAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovTypeEvents(uint64(m.Amount))
	}
	return n
}

func (m *EventRewardsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = m.CacaoPoolReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.MayaFundReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventRefund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypeEvents(uint64(m.Code))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBondV105) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *GasPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CacaoAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	return n
}

func (m *EventGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReserveContributor.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventScheduledOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.SlashAmount) > 0 {
		for _, e := range m.SlashAmount {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSlashLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeBondAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.LpUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventErrata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTssKeygenSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FailReason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.IsUnicast {
		n += 2
	}
	if len(m.BlameNodes) > 0 {
		for _, s := range m.BlameNodes {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = len(m.Round)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventTssKeysignMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventSlashPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SlashPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.SlashPoints))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventPoolBalanceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolChange.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Burn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitchV87) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Burn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Mint.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventMAYANameV111) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RegistrationFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.FundAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTypeEvents(uint64(m.Expire))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventMAYAName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RegistrationFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.FundAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTypeEvents(uint64(m.Expire))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.AffiliateBps != 0 {
		n += 1 + sovTypeEvents(uint64(m.AffiliateBps))
	}
	if len(m.SubaffiliateName) > 0 {
		for _, s := range m.SubaffiliateName {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	if len(m.SubaffiliateBps) > 0 {
		for _, e := range m.SubaffiliateBps {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSetMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetNodeMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventCACAOPoolDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.CacaoAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventCACAOPoolWithdrawV118) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.CacaoAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.AffiliateBasisPts != 0 {
		n += 1 + sovTypeEvents(uint64(m.AffiliateBasisPts))
	}
	l = m.AffiliateAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AffiliateAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventCACAOPoolWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.CacaoAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.AffiliateBasisPts != 0 {
		n += 1 + sovTypeEvents(uint64(m.AffiliateBasisPts))
	}
	l = m.AffiliateAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTradeAccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.CacaoAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func sovTypeEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypeEvents(x uint64) (n int) {
	return sovTypeEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolMod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacaoAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssetAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamingSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamingSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamingSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TradeTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.In.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedSwaps = append(m.FailedSwaps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypeEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypeEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedSwaps) == 0 {
					m.FailedSwaps = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypeEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedSwaps = append(m.FailedSwaps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwaps", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwapReasons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedSwapReasons = append(m.FailedSwapReasons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInCacao", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFeeInCacao.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapQuantity", wireType)
			}
			m.StreamingSwapQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapQuantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapCount", wireType)
			}
			m.StreamingSwapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAffiliateFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAffiliateFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAffiliateFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mayaname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mayaname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrossAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GrossAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBpsTick", wireType)
			}
			m.FeeBpsTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeBpsTick |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFeeBps", wireType)
			}
			m.SubFeeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubFeeBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asymmetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitCacao", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitCacao.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpLossProtection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ImpLossProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPendingLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPendingLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPendingLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingType", wireType)
			}
			m.PendingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingType |= PendingLiquidityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDonate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewardsV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewardsV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewardsV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoPoolReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoPoolReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MayaFundReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MayaFundReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRefund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBondV105) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBondV105: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBondV105: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, GasPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveContributor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventScheduledOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventScheduledOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventScheduledOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAmount = append(m.SlashAmount, PoolAmt{})
			if err := m.SlashAmount[len(m.SlashAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeBondAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeBondAddress = append(m.NodeBondAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeBondAddress == nil {
				m.NodeBondAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LpUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventErrata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, PoolMod{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InTxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenSuccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_mayachain_mayanode_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnicast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlameNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlameNodes = append(m.BlameNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_mayachain_mayanode_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeysignMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
			}
			m.SlashPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolBalanceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = append(m.ToAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAddress == nil {
				m.ToAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Burn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitchV87) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitchV87: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitchV87: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = append(m.ToAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAddress == nil {
				m.ToAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Burn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMAYANameV111) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMAYANameV111: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMAYANameV111: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = gitlab_com_mayachain_mayanode_common.Chain(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMAYAName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMAYAName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMAYAName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = gitlab_com_mayachain_mayanode_common.Chain(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateBps", wireType)
			}
			m.AffiliateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateBps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaffiliateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaffiliateName = append(m.SubaffiliateName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaffiliateBps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Uint
			m.SubaffiliateBps = append(m.SubaffiliateBps, v)
			if err := m.SubaffiliateBps[len(m.SubaffiliateBps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetNodeMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetNodeMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetNodeMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCACAOPoolDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCACAOPoolDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCACAOPoolDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = append(m.CacaoAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.CacaoAddress == nil {
				m.CacaoAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCACAOPoolWithdrawV118) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCACAOPoolWithdrawV118: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCACAOPoolWithdrawV118: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = append(m.CacaoAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.CacaoAddress == nil {
				m.CacaoAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateBasisPts", wireType)
			}
			m.AffiliateBasisPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateBasisPts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AffiliateAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffiliateAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCACAOPoolWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCACAOPoolWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCACAOPoolWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = append(m.CacaoAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.CacaoAddress == nil {
				m.CacaoAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CacaoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateBasisPts", wireType)
			}
			m.AffiliateBasisPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateBasisPts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AffiliateAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacaoAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacaoAddress = gitlab_com_mayachain_mayanode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_mayachain_mayanode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypeEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypeEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypeEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypeEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypeEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypeEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypeEvents = fmt.Errorf("proto: unexpected end of group")
)
